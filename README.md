# 这是一个简单的用中文来编写 js 的包

## 安装

```shell
    npm i cncode

    yarn add cncode
```

## 导入

```javascript
const { 打印, 固定循环, 条件循环, 数组工具 } = require("cncode");
```

## 打印模块

```javascript
const { 打印 } = require("cncode");

打印.日志("666"); //输出:666
打印.报错("啥"); //输出:啥
```
## 变量与常量
```javascript
const { 常量,变量 } = require('cncode');
// 常亮与变量都是全局可以访问的
// 变量 用来保存需要后续使用的值
// 声明变量传入 2个参数 第一个为变量名 第二个为变量值 

变量('b',2)  
变量('二',[123])
// 如果变量名重复 后面设置的值会替换之前的值
变量('b',2.2)  
//变量名可以是任意类型 但需要之前声明过 
变量(1,"666")
变量(变量('二'),"这是数组类型的变量名")
// 获取变量只需要传入变量名 
打印.日志(
    变量('b'),
    变量('二'),
    变量(1),
    变量(变量('二'))
)
/**
 * 控制台输出 
 * 2.2 
 * [ 123 ] 
 * 这是一个变量值 
 * 666 
 * 这是数组类型的变量名
 *  */ 

//常量
//常量声明后无法变更 常量名只支持数字和字符串
常量('A',1)
常量('B',2)
常量(1,'一')
//获取常量值只需要传入常量名
打印.日志(常量('A'),常量('B'),常量(1))
//控制台输出: 1 2 一

//尝试修改常量
常量('A',100)
//控制台报错:Error: 不能重复定义全局常量 A

```
## 数学

```javascript
const { 九章算数 } = require("cncode");

九章算数.π; // 返回 3.141592653589793
九章算数.向上去整(1.2); //返回 2
九章算数.向下取整(1.9); //返回 1
九章算数.四舍五入(2.5); //返回 3
九章算数.四舍五入(2.4); //返回 2
九章算数.绝对值(-12); //返回 12
九章算数.调整小数点(1.2323, 2); //返回1.23
九章算数.取最大值(10, 2, 3, 5, 6, 7, 8, 1); //返回10
九章算数.取最小值(10, 2, 3, 5, 6, 7, 8, 1); //返回1
```

## 流程控制

### 若

```javascript
const { 若 } = require('cncode');

变量('满分',100)
变量('及格线',60)
常量('阅卷函数',(分数)=>{
    若(
        分数 < 变量('及格线'), //条件
        ()=> 打印.日志('成绩不合格')
    )
    .或若(
        分数 === 变量('及格线'),
        ()=>打印.日志('成绩刚好合格')
    )
    .或若(
        分数 > 变量('及格线'),&& 分数 <= 80, //条件 60 - 80 为良好
        ()=>打印.日志('成绩良好')
    )
    .或若(
        分数 > 80 && 分数 < 变量('满分'), //条件 80 - 99 为良好
        ()=>打印.日志('成绩优秀')
    )
    .反之( //上述的条件都不成立则运行
        ()=>打印.日志('恭喜你拿了满分')
    )
})
常量('阅卷函数')(10) //控制台输出 成绩不合格
常量('阅卷函数')(60) //控制台输出 成绩刚好合格
常量('阅卷函数')(90) //控制台输出 成绩优秀
常量('阅卷函数')(100) //控制台输出 恭喜你拿了满分
```

### 对号入座

```javascript
const { 对号入座 } = require('cncode');
常量(
    '解析指令',
    (指令)=> 对号入座(指令,'解析不成功') // 第一个参数为解析的值 第二个为设置默认值 未匹配到时使用默认值
        .为(0).则(()=>'指令解析成功,当前指令意思是溜了溜了')
        .为(1).则(()=>'指令解析成功,当前指令意思是爱了爱了')
        .为(2).则(()=>'指令解析成功,当前指令意思是累了累了')
        .为(3).则(()=>'指令解析成功,当前指令意思是还有3秒就要揍人了')
        .为(4).则(()=>'指令解析成功,当前指令意思是yyds')
        .其值
    
)
打印.日志(
    常量('解析指令')(0), //控制台输出 指令解析成功,当前指令意思是溜了溜了
    常量('解析指令')(1), //控制台输出 指令解析成功,当前指令意思是爱了爱了
    常量('解析指令')(2), //控制台输出 指令解析成功,当前指令意思是累了累了
    常量('解析指令')(3), //控制台输出 指令解析成功,当前指令意思是还有3秒就要揍人了
    常量('解析指令')(4), //控制台输出 指令解析成功,当前指令意思是yyds
    常量('解析指令')(5)  //控制台输出 解析不成功
)
```

## 循环模块
### 固定循环
```javascript
const { 固定循环 } = require("cncode");

固定循环({ 次数: 3, 动作: (n) => 打印.日志(`第${n}次`) });
/*
输出:
第1次
第2次
第3次
 */
```
### 条件循环
```javascript
const { 条件循环 } = require("cncode");
变量('随机数', 九章算数.随机整数(1, 100))

条件循环({
    条件函数: () => 变量("随机数") < 90, //条件函数返回布尔值 当返回值为false时 停止动作
    动作函数: () => {
        打印.日志(
            变量('随机数')
        )
        变量('随机数', 九章算数.随机整数(1, 100))

    },
    前置运行: true, //可选 默认不前置运行一次
    结束动作: (n) => {
        //可选 会默认传入运行次数
        打印.日志(`结束了一共运行了${n}遍`);
    },
});

/*
控制台输出:
62
72
32
35
86
27
88
45
3
6
结束了一共运行了10遍
*/
```
## 数学



## 数组操作

```javascript
const { 数组工具 } = require("cncode");
变量('数组1',[1,11,111,2,22,222,3,33,333,1,2,3])

变量('去重的数组1',数组工具.去重(变量('数组1')))
打印.日志(
    变量('去重的数组1')
) //控制台输出 [1, 11, 111, 2, 22,222, 3, 333, 333,]

打印.日志(
    变量('数组1')
) //控制台输出 [1,11,111,2,22,222,3,33,333,1,2,3,]



打印.日志(
    数组工具.切片(
        变量('数组1'),1,2 
    )
) //控制台输出 [11,111]
打印.日志(
    数组工具.切片(
        变量('数组1'),-1,-5
    )
) //控制台输出 [ 3, 2, 1, 333, 33 ]

数组工具.删除元素(111,变量('数组1'))
数组工具.删除元素(222,变量('数组1'))
数组工具.删除元素(333,变量('数组1'))

打印.日志(
    变量('数组1')
) //控制台输出 [1, 11, 2, 22, 3, 33,1,2,3]

```

## 计时器模块

```javascript
const { 时间 } = require("cncode");
时间.同步等待(2000, true);
// 同步等待: (秒数?: number 毫秒, 开启日志?: boolean) => void
/*
开始等待
等待计时: 2.000s
 */

时间.异步等待(() => {
  //自动清除计时器标识
  // 异步等待: (回调函数?: () => void, 秒数?: number 毫秒) => void
  打印.日志(666);
}, 1000);

const 清理函数 = 时间.循环定时器((n) => {
  //返回清理当前循环计时器标识的函数
  打印.日志(n);
}, 1000);
/**
循环定时器: (回调函数?: (n?: 次数) => void, 秒数?: number 毫秒) => {
    清理函数: () => void;
}
输出
1
2
3
4
5
6
7
.....
 */
```

## 错误捕获

```javascript
常量(
    '报错的函数',
    ()=>{
        常量('a',1)
        常量('a',2)
    }
)
错误处理
.运行(常量('报错的函数'))
.捕获(
    (错误)=>{
        打印.日志(错误) // 主动输出错误: Error: 不能重复定义全局常量 a
        打印.日志('捕获成功',"不影响运行") //控制台输出 捕获成功 不影响运行
        
    }
)

```

## 额外说明

大多数的情况下 想获取流程控制 若 对号入座 中的 返回值 或者 错误处理中的返回值 
往往只需要再语句的最后加上  .其值 并且用变量接收即可

